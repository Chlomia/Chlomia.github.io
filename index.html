<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>粒子效果的爱心</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background: black; /* 修改背景为黑色以突出粒子效果 */
            overflow: hidden; /* 防止粒子溢出 */
        }

        canvas {
            position: absolute;
        }

        .heart {
            display: none; /* 隐藏原来的心形 */
        }

        .floating-heart {
            position: absolute;
            bottom: 0;
            color: #F8CCD9;
            animation: floatUp 5s linear infinite;
            pointer-events: none;
        }

        @keyframes floatUp {
            0% {
                transform: translateY(0);
                opacity: 1;
            }
            100% {
                transform: translateY(-100vh);
                opacity: 0;
            }
        }

        /* 照片墙样式 */
        .photo-wall {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 10px;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding: 20px;
            box-sizing: border-box;
            background: black;
            display: none; /* 初始隐藏照片墙 */
        }

        .photo-wall img {
            width: 100%;
            height: auto;
            border-radius: 10px;
        }
    </style>
</head>
<body>
    <audio src="D:\代码\爱心\暗流.mp3" autoplay loop >
    </audio>
    <script>
        const canvas = document.createElement('canvas');
        document.body.appendChild(canvas);
        const ctx = canvas.getContext('2d');

        let particles = [];
        const heartShape = [];

        for (let t = 0; t < Math.PI * 2; t += 0.05) {
            const x = 16 * Math.sin(t) ** 3;
            const y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
            heartShape.push({ x: x * 10, y: -y * 10 });
        }

        function initParticles() {
            particles = []; // 清空粒子数组
            for (let i = 0; i < 10000; i++) {
                const point = heartShape[Math.floor(Math.random() * heartShape.length)];
                particles.push({
                    x: canvas.width / 2 + point.x,
                    y: canvas.height / 2 + point.y,
                    vx: Math.random() * 2 - 1,
                    vy: Math.random() * 2 - 1,
                    alpha: Math.random(),
                });
            }
        }

        const colors = ['#F8CCD9', '#F4B3C5', '#EF8BA6']; // 定义三种颜色

        let scale = 1; // 初始缩放比例
        let scaleDirection = 1; // 缩放方向

        function animateHeartBeat() {
            scale += scaleDirection * 0.002; // 调整缩放比例，使跳动频率接近成年人的心跳频率
            if (scale > 1.2 || scale < 1) {
                scaleDirection *= -1; // 反转缩放方向
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save(); // 保存当前状态
            ctx.translate(canvas.width / 2, canvas.height / 2); // 将画布原点移到中心
            ctx.scale(scale, scale); // 应用缩放
            ctx.translate(-canvas.width / 2, -canvas.height / 2); // 恢复原点位置

            particles.forEach((p) => {
                p.x += p.vx;
                p.y += p.vy;
                p.alpha -= 0.01;
                if (p.alpha <= 0) {
                    p.alpha = Math.random();
                    const point = heartShape[Math.floor(Math.random() * heartShape.length)];
                    p.x = canvas.width / 2 + point.x;
                    p.y = canvas.height / 2 + point.y;
                }
                ctx.globalAlpha = p.alpha;
                ctx.fillStyle = colors[Math.floor(Math.random() * colors.length)]; // 随机颜色
                ctx.beginPath();
                ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
                ctx.fill();
            });

            ctx.restore(); // 恢复状态
            animateHeartBeat(); // 调用跳动动画
            drawText(); // 在每帧绘制时添加文本
            requestAnimationFrame(draw);
        }

        function drawText() {
            ctx.font = '48px Segoe Script'; // 设置字体样式和大小
            ctx.fillStyle = '#F4B3C5'; // 修正颜色代码
            ctx.textAlign = 'center'; // 文本居中对齐
            ctx.fillText('Love U', canvas.width / 2, canvas.height / 2); // 在画布中心绘制文本
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            initParticles(); // 重新初始化粒子
        }

        // 添加事件监听器以确保网页适应用户设备
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas(); // 初始化时调用以适应屏幕大小

        draw();

        // 恢复漂浮小爱心的功能
        function createFloatingHeart() {
            const heart = document.createElement('div');
            heart.className = 'floating-heart';
            heart.innerText = '❤';
            document.body.appendChild(heart);

            const size = Math.random() * 10 + 30; // 随机大小
            heart.style.fontSize = `${size}px`;
            heart.style.left = `${Math.random() * 100}vw`; // 随机水平位置
            heart.style.animationDuration = `${Math.random() * 3 + 2}s`; // 随机动画时长

            setTimeout(() => {
                heart.remove(); // 动画结束后移除小爱心
            }, 5000);
        }

        // 每100毫秒生成一个小爱心
        const floatingHeartInterval = setInterval(createFloatingHeart, 100);

        // 确保照片墙显示时不影响小爱心的漂浮效果
        setTimeout(() => {
            // 照片墙逻辑保持不变
            const photoWall = document.createElement('div');
            photoWall.className = 'photo-wall';
            photoWall.style.overflow = 'hidden';
            photoWall.style.whiteSpace = 'nowrap';
            photoWall.style.display = 'flex';
            photoWall.style.alignItems = 'center';
            photoWall.style.justifyContent = 'flex-start';
            photoWall.style.height = '100%';
            photoWall.style.padding = '20px';
            photoWall.style.position = 'absolute';
            photoWall.style.top = '0';
            photoWall.style.left = '0';
            photoWall.style.width = '100%';
            photoWall.style.height = '100%';
            photoWall.style.zIndex = '1';
            photoWall.style.background = 'black';
            photoWall.style.opacity = '0';
            photoWall.style.transition = 'opacity 2s';
            document.body.appendChild(photoWall);

            const photoPaths = ['2018.jpg', '1.jpg', '2.jpg', '3.jpg','大坏蛋.jpg', '小坏蛋.jpg', '小坏蛋2.jpg', '大坏蛋2.jpg', '4.jpg', '5.jpg', '6.jpg', '2025.jpg'];
            photoPaths.forEach(photo => {
                const img = document.createElement('img');
                img.src = photo;
                img.style.width = '150px';
                img.style.height = 'auto';
                img.style.margin = '0 10px';
                img.style.flexShrink = '0';
                photoWall.appendChild(img);
            });

            photoPaths.forEach(photo => {
                const img = document.createElement('img');
                img.src = photo;
                img.style.width = '150px';
                img.style.height = 'auto';
                img.style.margin = '0 10px';
                img.style.flexShrink = '0';
                photoWall.appendChild(img);
            });

            let scrollAmount = 0;
            function scrollPhotos() {
                scrollAmount += 2;
                photoWall.scrollLeft = scrollAmount;
                if (scrollAmount >= photoWall.scrollWidth / 2) {
                    scrollAmount = 0;
                }
                requestAnimationFrame(scrollPhotos);
            }

            canvas.style.transition = 'opacity 2s';
            canvas.style.opacity = '0';

            setTimeout(() => {
                photoWall.style.opacity = '1';
                scrollPhotos();
            }, 2000);
        }, 7000);
    </script>
</body>
</html>
